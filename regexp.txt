-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
||| Представление символов и метасимвол  |||=======>
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%B3%D1%83%D0%BB%D1%8F%D1%80%D0%BD%D1%8B%D0%B5_%D0%B2%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F
https://cheatography.com/davechild/cheat-sheets/regular-expressions/
regex101.com
https://regexr.com/
https://www.regular-expressions.info

/java/
java \ python ruby1.9 javascript c#
 / — его называют разделитель (delimiter). Его указывают в начале и конце 
регулярного выражения, чтобы отделить регулярное выражение от остального текста.

/\\/ - экранирование слеша
/\./ - экранирование точки


 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 |||     Символьные классы            |||=======>>
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

/ [a-z]/ 
/ [0-9]/
 символьные классы.
/ \d/ - цифры
Если мы укажем заглавную букву D, 
то в результате поиска получим все остальные 
символы — в том числе, пробелы и табуляцию:

Использование класса \w равносильно такой записи: [0-9a-zA-Z_].

test =0=0=0=0

\d\d\/[^a-z]

=============

Первый и второй символы — это цифры
Третий символ — это /
Четвертый символ — любой, кроме a-z

////

 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 |||     Позиция внутри строки         |||=======>>>
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Символ для поиска в начале строки:
/^java/

Теперь добавим $ и получим всего одно совпадение — в конце строки:
/script$/

символы a, которые находятся в конце слова. Для этого наберем в шаблонной строке a\b:
/a\b/

Используя тот же символ в верхнем регистре \B, 
мы можем инвертировать поиск. Так мы найдем все символы a, не находящиеся в конце слова:
/a\B/

TEST

Напишите регулярное выражение, которое находит строку, содержащую только support@hexlet.io. 
Такие строки, как something here support@hexlet.io и support@hexlet.io something here не попадают под регулярное выражение.

^support@hexlet\.io$

=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-


 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 |||          Альтернатива            ||| =======>>>>
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

альтернатива — укажем первый возможный вариант и через вертикальную черточку — второй. Так мы получим следующее сопоставление:
/gray|grow/
/gr(ay|ow)/
/gr[ae]y/

 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 |||          Квантификация            ||| =======>>>>>
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Квантификация — это поиск последовательностей. 
Квантификатор — это специальный ограничитель, который указывает количество возможных повторений символа, 
группы символов или класса символов, находящихся в регулярном выражении перед ним. 

/colou?/
/col(ou)?r/
/col[ou]?r/

Еще один квантификатор — символ +. 
Предшествующий ему символ, группа или класс символов, 
должны встречаться как минимум один раз.

/colou+r/


Символ * говорит об отсутствии повторений или о повторении один или несколько раз.

/colou*r/
/colou{2}r/

TEST ==..==..==..==..==
^\w+@[a-zA-Z]{3,}\.[a-zA-Z]{2,5}$
^\w{1,}@[a-zA-Z]{3,}\.[a-zA-Z]{2,5}\b - мой вариант
________________________________________________
Часть до @ должна содержать только символы класса \w в количестве не менее одного
Часть после @ и до ., после которой начинается домен, должна содержать только буквы и быть не короче трех символов (например, hexlet)
Часть после . может содержать только буквы и быть от двух до пяти символов в длину (например, io)
==..==..==..==..====..==..==..==..==


 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 |||          Жадность                 ||| =======>>>>> нужно доработать
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

В противоположность жадной квантификации существует ленивая. 
В ленивой мы захватываем минимальную подстроку. 
Чтобы из жадной квантификации сделать ленивую, нужно использовать специальный символ ?:

В противоположность жадной квантификации существует ленивая. 
В ленивой мы захватываем минимальную подстроку. 
Чтобы из жадной квантификации сделать ленивую, нужно использовать специальный символ ?:

тест
\(.+?\)
Напишите регулярное выражение, которое находит подстроки, состоящие из:
(
Хотя бы одного любого символа
)

 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 ||| Группировка. Обратная связь       ||| =======>>>>> 
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

/(ta|tu)/

Здесь поможет группировка с обратной связью. 
Чтобы сделать ее, мы используем специальное обозначение \1. 
Оно указывает, что символы из первой группы нужно подставить вместо \1.
Таким образом, совпадают подстроки с одинаковыми левыми и правыми частями:
/(ta|tu)-\1/
ta-ta tu-tu

По умолчанию все созданные группы символов записываются в специальную область памяти и маркируются символами от \1 до \9.

Если вы используете несколько групп, то не очень удобно запоминать их по номерам. 
Гораздо проще пользоваться именами. Для этого нужно добавить ?<имя> после открытия скобки:
/(?<group1>ta|tu)-\k<group1>/

Мы можем отключить обратную связь, поставив ?: внутри нашей группы:
/(?:ta|tu)-\1/

ТЕСТ:
(?<group1>[a-z]{3})\:\k<group1> мое именнованое
([a-z]{3}):\1
Напишите регулярное выражение, которое находит подстроки, состоящие из:
Трех символов из класса a-z:
Группы символов из первого условия

 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 |||        Модификаторы               ||| =======>>>>> 
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

https://www.regular-expressions.info/modifiers.html

Модификаторы — это символы, которые указываются после знака ? 
в группе символов регулярного выражения и меняют их поведение.

Если после ? мы поставим i, то включим режим игнорирования регистра. 
Мы получим сопоставление еще одной подстроки, но уже не с t в нижнем регистре, а с T в верхнем:
/(?i:t.)-(?:t.)/

 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 |||     Просмотр вперед и назад      ||| =======>>>>> 
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

Большинство реализаций регулярных выражений поддерживают две полезные функции:
Просмотр вперед — опережающий поиск (lookahead)
Просмотр назад — ретроспективный поиск (lookbehind)

 
/Ludovic(?=XVI)/
/Ludovic(?!XVI)/

/(?<=One )Two/
/(?<!One )Two/


TEST:
80(?=:[^a-z])
Напишите регулярное выражение, которое находит подстроку 1, за которой следует подстрока 2:
1 - 80
2 - : и один или более символов, не входящих в класс a-z

 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 |||     Просмотр вперед и назад      ||| =======>>>>> 
 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=






TEST
("|')python\1
ig
Напишите регулярное выражение, которое находит все подстроки python, заключенные в двойные " или одинарные ' кавычки. При этом вам нужно найти все варианты вне зависимости от регистра (Python, pytHon, pYThon и так далее).









